#  TF1_H2A.Bbd_metagene_plots.R
#
#  Copyright 2015 Sebastian Kurscheid <sebastian.kurscheid@anu.edu.au>
#  
#  This program is free software; you can redistribute it and/or modify
#  it under the terms of the GNU General Public License as published by
#  the Free Software Foundation; either version 2 of the License, or
#  (at your option) any later version.
#  
#  This program is distributed in the hope that it will be useful,
#  but WITHOUT ANY WARRANTY; without even the implied warranty of
#  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
#  GNU General Public License for more details.
#  
#  You should have received a copy of the GNU General Public License
#  along with this program; if not, write to the Free Software
#  Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston,
#  MA 02110-1301, USA.
#  
# load libraries
library("biomaRt")
library("GO.db")
library("GenomicFeatures")
library("GenomicAlignments")
library("TxDb.Hsapiens.UCSC.hg19.knownGene")
library("rtracklayer")
library("AnnotationDbi")
library("BSgenome.Hsapiens.UCSC.hg19")
library("metagene")
library("GenomicRanges")


# load hg19 based Ensembl data # do this only once, save RData objects than recycle
load("/home/skurscheid/Data/Annotations/hsapiens_gene_ensembl_GRCh37.rda")
hsapEnsembl <- loadDb("/home/skurscheid/Data/Annotations/hsapiens_gene_ensembl_GRCh37_TxDB.sqlite")
load("/home/skurscheid/Data/Annotations/hsapiens_gene_ensembl_chromInfo_GRCh37.rda")

# load GRanges objects containing regions-of-interest
dest_dir <- "/home/skurscheid/Data/Annotations/hg19"
load(paste(dest_dir, "gr.tss_up1000_dn1000", sep = "/"))

# reset TxDB object to include canonical chromosomes
# and create GRanges with regions of interest
seqlevels(hsapEnsembl, force = TRUE) <- c(seq(1,22,1), "X", "Y", "MT")


bamDir <- "/home/skurscheid/Data/Tremethick/Alignments/"
bamFiles <- c(paste(bamDir, "Sample_TF1_1/TF1_1_L001_fill_coordinate_sorted_q20.bam", sep = ""),
              paste(bamDir, "Sample_TF1_2/TF1_2_combined_L001_fill_coordinate_sorted_q20.bam", sep = ""),
              paste(bamDir, "Sample_TF1_3/TF1_3_L001_fill_position_sorted_q20.bam", sep = ""),
              paste(bamDir, "Sample_TF1a_1/TF1a_1_combined_L001_fill_coordinate_sorted_q20.bam", sep = ""),
              paste(bamDir, "Sample_TF1a_2/TF1a_2_combined_L001_fill_coordinate_sorted_q20.bam", sep = ""),
              paste(bamDir, "Sample_TF1a_3/TF1a_3_combined_L001_fill_coordinate_sorted_q20.bam", sep = "")
              )

file.exists(bamFiles)

# for test run, only load chromosome 1 data
which <- GRanges(1, IRanges(1, as.numeric(chromInfo[1])), strand = "*")
seq_data <- sapply(bamFiles, function(x) import(x, which = which))
# get coverage
cov <- coverage(seq_data[[1]])

# idea is to extract the bp-level coverage from the RLE generated by coverage() function
chr1.tss.cov <- data.frame(lapply(gr.tss_up1000_dn1000[which(seqnames(gr.tss_up1000_dn1000) == 1 & end(gr.tss_up1000_dn1000) <= length(cov$"1"))], function(x) {df <- data.frame(coverage=cov$"1"[start(x):end(x)]); return(df)}))

# for full run, use canonical chromosomes, exclude other assembly artefacts
which <- GRanges(c(seq(1,22,1), "X", "Y", "MT"), IRanges(rep(1,25), as.numeric(chromInfo[1:25])), strand = "*")
seq_data <- sapply(bamFiles, function(x) readGAlignmentPairs(x)) # have to use readGAlignmentPairs instead of "import" function
gc()

# full profiling can be done in two steps
# first create coverage RLEs for each sample
library("snowfall")
sfInit(parallel = T, cpus = 6)
sfLibrary("GenomicAlignments")
sfExport(seq_data)
cov.all <- sfLapply(seq_data, coverage)
sfStop()

# use only the 25 canonical chromosomes in the coverage list
canonicalChr <- c(seq(1,22,1), "X", "Y", "MT")
cov.all <- lapply(cov.all, function(x) x[canonicalChr])

cov.all.lengths <- unlist(lapply(cov.all), function(x) length)

# we have some discrepanices between the length of the reference genomes that the reads were mapped to
# and the annotation we used for determining TSS
# therefore we create a new GRangesList object containing only TSS which are contained within the aligned reads
l1 <- sapply(canonicalChr, function(x) lapply(cov.all[1], function(y) length(y[[x]])))
l1 <- as.numeric(lapply(l1, function(x) unlist(x)))
names(l1) <- canonicalChr
grl.tss_up1000_dn1000 <- GRangesList(sapply(canonicalChr, function(x) gr.tss_up1000_dn1000[which(seqnames(gr.tss_up1000_dn1000) %in% x & end(gr.tss_up1000_dn1000) <= l1[x])]))


# second, create bp-level data per region of interest
library(snowfall)
sfInit(parallel = TRUE, cpus = 24)
sfLibrary(GenomicRanges)
sfLibrary(GenomicFeatures)
sfLibrary(GenomicAlignments)
sfExport("grl.tss_up1000_dn1000")
sfExport("cov.all")
sfExport("canoncicalChr")

tss.cov <- sfApply(grl.tss_up1000_dn1000, function(x) {df <- data.frame(coverage=cov.all[start(x):end(x)]); return(df)}))

chr1.tss.cov <- data.frame(sfLapply(gr.tss_up1000_dn1000[end(gr.tss_up1000_dn1000) <= length(cov$"1"))], function(x) {df <- data.frame(coverage=cov$"1"[start(x):end(x)]); return(df)}))
chr1.tss.cov$meanCov <- sfApply(chr1.tss.cov, 1, mean)
chr1.tss.cov$medianCov <- sfApply(chr1.tss.cov, 1, median)

sfStop()



# technically we can now plot e.g. the mean coverage like this
chr1.tss.cov$meanCov <- apply(chr1.tss.cov, 1, mean)
chr1.tss.cov$medianCov <- apply(chr1.tss.cov, 1, median)



# metagene package
design <- data.frame(Samples = as.character(bamFiles),
                     align1 = c(1,1,1,0,0,0), 
                     align2 = c(0,0,0,1,1,1))
groupsFeatures <- parseFeatures(bamFiles=bamFiles, design=design, specie="human", maxDistance=1000, cores = 6)
